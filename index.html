<!DOCTYPE html>
<html>
  	<head>
     <title>Software Prototyping</title>
     <meta charset="utf-8">
     <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3,h4{
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
     </style>
  	</head>
    <body>
	     <textarea id="source">
          #<center>** Prototyping**</center>
          <img src="img/prototyping1.png" width="800" height="500" align="middle" />




          ---
          ##<center>**Table of Contents**</center>


          ---
          ##<center>**What is prototyping**</center>
          ___
          ### A prototype is an incomplete version of a software system being developed, that is used to demonstrate concepts, try out design options and, generally, to find out more about the problem and its possible solutions.

          + It is built so that the users can experience some of the proposed features and functionality of the software.
          <br>
          <br>
          + Typically, it simulates only a few aspects of the features of the final system, but may be completely different from the final implementation.
          ---

          ##<center>**Need for prototyping**</center>
          ___

          + ### A better quality system can be delivered
          <p style='text-align: justify;'>
          Many a times the developers may not fully understand the requirements and the expectations of the end users. Prototyping enables that the misunderstandings which occur can be identified and sorted out early on in the process.
          </p>

          + ### Problems can be identified early on
          <p style='text-align: justify;'>
          Using a prototype, makes a working system available early on in the process. The user can then identify possible improvements which can be made before the system is completed.
          </p>

          ---
          ##<center>**Need for prototyping**</center>
          ___

          + ### Better involvement of end users
          <p style='text-align: justify;'>
          The end user feels more involved in the development of the system and will 'buy' into it.
          </p>


          + ### Leads to fulfillment of user requirements
          <p style='text-align: justify;'>
          A system which has been through prototyping will generally have an improved design quality and will be far closer to what the user needs.

          </p>

          + ### Cost savings
          <p style='text-align: justify;'>
          Identifying and rectifying the problems with the system in the early stages of development is less expensive than towards the end of the development phase.
          </p>

          + ### Training
          <p style='text-align: justify;'>
          The prototype developed can be used to help train the staff while the real system is still being under development.

          </p>
          ---

          ##<center>**Hardware Prototyping  vs  Software Prototyping**</center>
          ___

          ###Software prototyping and hardware prototyping have different objectives.


          + While developing hardware systems, a prototype is generally used to validate the system design.  eg. A prototype for an electronic system may be developed using previously used  components before investment is made in expensive and special integrated circuits to build the final version of the system.
          <br>
          <br>

          + A software prototype is not normally intended for design validation but to help develop and check the reality of the requirements for the system. The prototype design is usually different from that of the final software system.
          ---

          ##<center>**The process of prototype development**</center>
          ___
          <img src="img/PrototypingObjectives.PNG" width="800" height="300" align="middle" />

          ---

          ##<center>**The process of prototype development**</center>
          ___
          A process model for prototype development is shown in the previous figure.

          + The objectives of prototyping should be made explicit and definite from the start of the process. These objectives can be to develop a system for prototyping the user interface, or to validate functional requirements of the system or a prototype to demonstrate the feasibility of the the proposed system to the management. <br>
          The same prototype cannot satisfy all the objectives. Leaving the objectives unstated, may lead to  misunderstanding of the function of the prototype to the management or end-users.

          + The next stage in the process is to decide what to include and more importantly, what to leave out of the prototype system. We need to exclude some functionality out of the
          prototype to reduce prototyping costs and speed up the delivery schedule. <br>
          We can also exclude the non-functional requirements such as response
          time, memory utilization, security, reliability.

          ---


          ##<center>**The process of prototype development**</center>
          ___

           + After building the prototype, the final stage of the process is that of prototype evaluation. <br>

           Provision must be made during this stage for user training, and the prototype objectives should be used to derive a plan for evaluation. Users need time to adapt with a new system and to settle into a normal pattern of usage. Once they start using the system normally, they then are able to discover problems in requirements and other missing features.

          ---


           ##<center>**Prototypes as design artifacts**</center>
          ___


          When successful prototypes are viewed as artifacts of design process,
          we can find several similar characteristics in them.

          + They support creativity and help the developer in capturing and generating ideas, and in gathering relevant information about the users and their background.


          + They enable communication between the various stake holders, helping designers, engineers,
          managers, software developers, customers and users to interact with each other.

          + They also permit early evaluation through usability studies and informal user
          feedback, throughout the design process.


          ---

          ##<center>**Prototypes as design artifacts**</center>
          ___


          Prototypes and prototyping techniques can be analyzed along four dimensions:
          + Representation describes the tangible forms of the prototype, e.g., paper
          sketches or computer simulations.
          <br><br>
          + Precision describes the level of detail at which the prototype is
          evaluated e.g. A rough prototype or a highly polished one.
          <br><br>
          + Interactivity describes the extent to which the user can interact with
          the prototype e.g., view-only prototype or a fully interactive one.
          <br><br>
          + Evolution describes the expected life-cycle of the prototype. e.g. throwaway
          or iterative.


          ---

           ##<center>**Representation**</center>
          ___

          A prototype can be series of paper sketches or it can be a computer simulation showing the details. Based on these different forms, we can classify prototypes as:
          <br>

          + Off-line prototypes
            + These generally include paper sketches, whiteboard illustrations, cardboard mockups and videos.
            + They can be created quickly, usually during the early stages of design, and are
            usually thrown away after they have served their purpose.

          + On-line prototypes
            + These are computer based prototypes which include computer animations, interactive video presentations, programs written with scripting languages, and applications developed with interface builders.
            + The cost of producing such prototypes is usually higher, and skill requirement to build such prototypes is also high.
            + They are effective in the later stages of the design process, when the basic design strategy has been decided.

          ---
          ##<center>** Off-line vs On-line prototypes **</center>
          ___
          + Off-line prototypes are very inexpensive and quick to build. This allows a rapid iteration cycle and helps in examining a variety of design alternatives.

          + Off-line prototypes are less likely to constrain the thinking of the designer. The  programming languages or development environments used in on-line prototyping impose constraints on the interface, thereby limiting creativity and restricting the number of ideas.

          + Off-line prototypes have the advantage of being created by a wide range of people.
           It is limited not just to programmers, but all types of designers, users, managers and others can all contribute equally.

          +  However, off-line prototypes are are insufficient to fully evaluate a particular design idea. e.g. An interface which is required to give rapid feedback to the users or to produce dynamic visualizations will usually require on-line prototypes .

          ---

          ##<center>**Precision**</center>
          ___

          Precision is the level of details with respect to the purpose of the prototype. <br><br>
          e.g. While designing a dialog box, it is necessary to specify the size and positions of the various elements of the box. But it's not required to decide the actual content text in detail.

          + The aspects of the prototype that are not precisely stated are the ones which are open for further discussion or for exploration. <br><br>
          + The precision level increases with the development of successive prototypes and as more details are set. <br><br>
          + The representation forms of the prototypes reflect their level of precision: hand drawn sketches aren't that precise unlike computer simulations which are usually very precise.


          ---
          ##<center>**Interactivity**</center>
          ___

          Illustrating how the user will interact with the system is an important aspect of designing an interactive prototype. Prototypes can support different types of interaction -

          + Fixed prototypes are the non-interactive ones where the user cannot interact with them.
          e.g.video clips or pre-computed animations. Fixed prototypes simply portray what the interaction might look like.
          <br><br>
          + Open prototypes support large number of interactions. Such prototypes work like the
          real system, with some limitations. They usually only cover a certain part of the system and have limited performance and error-handling capabilities  as compared to the final system.


          ---

          ##<center>**Evolution**</center>
          ___
          Prototypes can be classified into the following based on their different life spans:
          + Rapid prototypes are built for a specific purpose and are then discarded away. They must be be inexpensive and easy to produce.<br><br>

          + Iterative prototypes are meant to evolve, either for working out specific details or for exploring different alternatives. <br><br>

          + Evolutionary prototypes are the ones which are designed to become part of the final system. As they are meant to be a part of the final system , they require greater planning and practice than the above approaches.


          ---


          ##<center>**Prototype Orientation**</center>
          ___
          The designer should decide what is the role of the prototype with respect to the final product and in which order to build the different aspects of the prototype. <br>
          The orientation of its design is also a major factor in helping out the software development teams.Based on their orientation, prototypes can be classified as:

          + **Horizontal prototypes**
            + They typically involve focusing on the interoperability over the functionality, more towards the user-interface. <br><br>
            + They help in getting an overall picture of the system from the userâ€™s perspective and
            address issues such as consistency (functions similar in nature can be accessed through similar user commands), coverage (all the required functions can be supported) and redundancy (no same function can be accessed through different commands). <br><br>
            + This type of prototyping is most commonly used by large software teams and tend to be progressively transformed into the final system. <br><br>

          ---

          ##<center>**Prototype Orientation (contd.)**</center>
          ___

          + **Vertical prototypes**
            + As compared to horizontal prototypes, vertical prototypes are highly functional, but generally only involves on a particular subset of features/functionality of the system.
            <br><br>
            + They are usually created to assess the feasibility of a feature and are generally higher in precision.<br><br>
            + They are often thrown away because they are generally created early in the project, and due to the fact that they focus on only a single design question. <br>


            <center><img src="img/Orientation.png" width="350" height="200" alt="Prototype Orientation" /></center>


          ---

          ##<center>**Prototyping strategies**</center>
          ___

          Software prototyping can be accomplished through different approaches. However, all of them are in some way based on the following two major types of prototyping:
          ###**Throwaway Prototyping**

          ###**Evolutionary Prototyping**

          ---

          ##<center>**Throwaway Prototyping  **</center>
          ___
          <br><br>
          <center><img src="img/ThrowawayProcess.PNG" width="750" height="300" alt="Throwaway Process " /></center>

          ---

          ##<center>**Throwaway Prototyping**</center>
          ___
          + Throwaway Prototyping (also called rapid prototyping) is the process of creating a model that will be discarded eventually rather than reusing the same one for the final delivered software.

            + After the preliminary requirements are understood, the developers build a simple working model of the system to show the customer/end-users what the end-product might look like when they are implemented into a final product.

            + The primary objective of this approach is to understand the system requirements clearly and provide additional information for managers to assess the risks involved. It usually starts with requirements that are poorly understood. Once the requirements are clarified, the system will be developed again from the beginning.
            This model is conducive when the requirements are vague but stable.

          ---

           ##<center>**Throwaway Prototyping (contd.) **</center>
          ___

          + The stakeholders and end-users should not give in to the temptation to turn the throwaway prototype into a delivered system. The reasons for this are:
            + Non functional aspects of the systems such as performance, security, robustness and reliability are generally ignored during prototype phase to enable rapid implementation. It may be not be possible to tune the prototype to meet these nonfunctional requirements.

            + During the prototype development phase, the prototype would have been tweaked to reflect the user needs. As these changes are likely to have been made in an uncontrolled way, they can probably degrade the system structure. Such a system is difficult and expensive to maintain.

          ---

          ##<center>**Advantages of Throwaway Prototyping  **</center>
          ___

          + Throwaway Prototyping can be done easily and quickly.

          + This model helps to ensure that that all the requirements are satisfied when the final product is built.

          +  Getting quick feedback helps to refine the requirements early on in the development process. Thereby, making changes early in the development lifecycle is extremely cost effective.

          + This approach helps in to define goals early on, identify potential problems and conduct risk assessment of the project as a whole.

          ---

          ##<center>**Disadvantages of Throwaway Prototyping **</center>
          ___

          + Some important features may have been left out of the prototype to simplify rapid implementation.

          +  Non functional aspects like security and reliability of the system may not be included in the prototype due to the short span of time.

          + It takes time and resources to actually undertake this prototyping.

          ---

           ##<center>**Off-line rapid prototyping techniques **</center>
          ___

          Off-line prototyping techniques range from simple to very elaborate. They are usually considered as means for thinking through the design issues, which are to be thrown away when no longer needed. <br>

          + **Paper & pencil**
            + The easiest and fastest form of prototyping involves sketching out on paper, transparencies and post-it notes to represent aspects of an interactive system.
            + Most paper prototypes start as quick sketches on paper and then progress to more detailed computer screen images.

          + **Mock-ups**
            + Mock-ups involve creating user interfaces that show the end user what the software will look like without actually building the software. Interface mock-ups can range from simple hand drawn screen layouts, through realistic bitmaps, to semi functional user interfaces developed in a software development tool.
            + Mock-ups allow the designer to concentrate on the physical design of the device, such as the position of buttons, labels, menus on the screen.

          ---

          ##<center>**Off-line rapid prototyping techniques (contd.) **</center>
          ___

          + **Wizard of Oz technique**
            + This technique gives the users the impression that they are working with a
            real interactive system.

            + This technique is based on a scene in the 1939 movie "Wizard of Oz".

            + A user sits on a system and interacts with a program. The software
            designer, acting as the wizard behind the scenes, watches the user's action. By responding in different ways, the designer creates the illusion of a working software program. In some cases, the user is unaware that a person, is operating the system.  

          ---

          ##<center>** On-line Prototyping Techniques**</center>
          ___


          The basic idea behind the prototyping approach is to be able to develop a prototype
          of a system as quickly as possible. This allows feedback from all stakeholders to
          be given early in the software process.

          The major on-line prototyping techniques are -

          - Executable specification languages

          - Very high-level languages

          - Composition of reusable components

          - Fourth-generation languages

          The above mentioned techniques can be used in combinations. Some part of the software
          system may use one technique while some other part could be done more efficiently using
          some other technique.

          ---
          ### 1. Executable Specification Techniques
          ___


          Using a formal specification to develop a prototype is useful as it combines unambiguous
          specification with a prototype. But when this is applied practically, there are many
          constraints -

          - Graphical user interfaces are extremely difficult to prototype using this technique. The

          - Prototype development may not be very rapid to start withusing this technique as it requires
          a detailed analysis of the system, functions, and features that were rejected earlier and features
          which need to be included.

          - Executable specifications mainly test only functional requirements.

          ---
          ### 2. Very high-level languages
          ___

          These  are generaally programming languages which have powerful data managament facilities and
          efficient memories. However, dynamic languages of this genre are not used as they requirea large
          run-time support system which in turn increases the storage that is required.

          Smalltalk is an object oriented programming language that is excellent for prototyping due to-

          - Rapid modifications of a Smalltalk system are possible without unforeseen effects on the rest of
          the system.

          - All the objects defined in the environment are available to the programmer which helps in reusability.

          - Partial automation in the construction of user interfaces for interactive systems is supported in some
          versions.
          ---
          ### 2. Very high-level languages (contd.)
          ___

          REFINE is a class of wide-spectrum programming languages used for prototyping.
          A wide-spectrum language is a programming langauge which combines a number of paradigms. It may include
          objects, imperative constructs and logic programming which are also provided separatelt by languages such as
          Pascal, Lisp and Prolog.

          The mixed language support involves programming different parts of the system in different languages. A commication
          framework needs to be estabilished between the different parts in this case.

          The advantage of this approach is that for each part, the most appropriate language can be chosen which can speed up
          prototype development.

          The disadvantage is that it may be diffuclt to estabilish an interface which allows the communcation of multiple languages

          ---
          ### 3. Reusable Components
          ___

          Reusable components are useful as they reduce the time taken to develop a prototype. Having a library of reusable components
          and some mechanism to use them into the exisiting system leads to faster development. Another advantage is that they help in
          reducing the overall costs.

          The system specification has to take into account which of the reusable components are available.
          Sometimes this approach is combined with other approaches such as using fourth-generation languages.


          <center><center>
          ![Reusable Components](img/Component reusability.PNG)

          ---
          ### 4. Fourth-generation languages
          ___

          At their simplest, these languages could be database languages such as SQL. Since they are commonly used to develop business
          systems, they may also include a package for a report genreator and a powerful interactive facility for application generation.

          They rely on software reuse where common abstractions have been idenitifiedand parameterized.The programmer only needs to
          describe how routines for database access and report production need to be tailored and controlled.

          <center><center>
          ![Fourth-generation languages](img/Fourth generation languages.png)

          ---
          ### 4. Fourth-generation languages (contd.)
          ___

          Systems using such languages are simpler to maintain as the developed application prototypes are smaller in this case compared to its
          counterparts such as COBOL. For these smaller systems, it is also more cost-effective.

          <u>**Disadvantages:**</u>
          - These languages are slower compared to conventional programming languages and require much more memory.

          - There is no standardization across fourth-generation languages. This could lead to higher costs due to having to rewrite a program.
          In the long run, even though they could lead to lower development costs, the overall cost could be higher.

          <u>**Advantages:**</u>
          - They are generally used along with CASE tools for development of small-medium sized systems. Using such systems has the advantage that
          documentation is produced at the same time as the protoype system.

          - The developed system should be more structured and easier to maintain.

          ---

          ##<center>**Evolutionary Protoyping**</center>
          ___

          <center><center><br><br><br><br><br>
          ![Evolutionary Protoyping](img/evolutionary.jpg)
          ---
          ##<center>**Introduction**</center>
          ___
          The main goal of the evolutionary prototyping approach is to develop a
          mature, efficient, reliable, cost-effective software system or a solution
          through a series of prototyping iterations.

          The prototype undergoes continuous iterations and gets refined at each iteration.
          At each iteration, the implementation is handed over to the customer for their
          feedback. Ultimately, what started out as the prototype should become the solution.

          At each iteration, the system can be considered as first draft, second draft and
          so on till the final version is ready. Evolutionary prototyping is useful in developing
          systems where it is extremely difficult to establish a detailed system specification document.

          ---
          ##<center>**Approach of Evolutionary Prorotyping**</center>
          ___

          An important factor that determines the success of this approach is the use of techniques and tools
          which allow for rapid system iterations. The changes that are suggested by the customer need to be
          incorporated and demonstrated again to the customer as quickly as possible. This can include the use
          of high level programming languages for software development, special environments, integrated software
          tools etc that can accelerate the developmen process.

          One key differnce between Evolutionary prototyping and specification-based approaches is the verification
          and validation. Verification is done by comparing the program, software system or solution to its
          specifications. Without having a specification, verification cannot be done. Validation process is done
          to ensure that the system is working as it is intended rather than its conformance to a speicifcation.

          ---
          ##<center>**Disadvantages**</center>
          ___

          Trying to decide how adequate a system is difficult as it is not measurable. Human performance is
          not always guaranteed to be correct but we are satisifed if performance is adequate for the current task.

          When it comes to developing systems that are expected to last a very long time, this could be a bigger
          problem. The main problems associated with evolutionary prototyoing are -

          - Prototypes usually develop so quickly that is not cost-effective to produce a great deal of system
            documentation and schedules.

          - Continuous changes to a system could lead to its corruption.

          - Generally for such approaches, small teams of highly skilled and passionate individuals have been used
            effectively. But it is still not clear as to what comprises the perfect team.

          - It is difficult to set a budget and schedule.

          ---
          ##<center>**Advantages**</center>
          ___

          - Since prototypes are generally developed quickly to get customer feedback quickly, this approach
          speeds up the delivery of the system. The changes suggested by the customer are implemented quickly
           and effectively.

          - The user is constantly involved with the team during the development of the software solution.

          - Constant customer interaction ensures that the end prodcut meets user requirements as much as possible.

          - There is constant refinement of the software product.

          - Compared to Throwaway Prototyping, the prototypes developed using this approach are functional prototypes,
           even though the developers may not have implemented all the features mentioned by the customer.

          ---
          ##<center>**Operational Prototyping**</center>
          ___

          - Operational prototyping is a disciplined approach to developing best pradices used by an organization to enhance value provided to customers through improved quality of care and reduced costs.

          - The main focus of operational prototyping is to take every element involved in a design process into consideration and then enhance it to the level of best practices.

          - It involves identifying functions, processes, and design elements that can be customized, optimized, standardized, and replicated throughout the organization, including across multiple sites.

          - Evolutionary prototyping and throwaway protoryping on their own aren't acceptable.
            - They both have their unique drawbacks that make them ineffective to be used on their own.

          ---
          ##<center>**Operational Prototyping**</center>
          ___

          - Operational prototyping starts with analyzing all the factors that affect the delivery of services to an organization and in the process pointing out where best practices lie.

          - An operational prototyping team will then set out to design effective models and solutions to achieve the desired state.

          - In the process of modeling, everything from registration of the service to its manufacturing to its supply chain management is looked at.

          - The next couple of slides look at a step by step working of Operational Prototyping

          ---
          ##<center>**How Operational Prototyping Works**</center>
          ___

          - A baseline is set by creating an evolutionary prototype and only requirements that are well understood are incorporated.

          - This baseline is made into copies and sent to an expert prototyper.

          - The job of the expert prototyper is to monitor how users react to the prototype.
            - At each site, the prototyper will monitor the user at the system.

          - If and when the user encounters a problem, the prototyper will make sure to record it.
            - This frees the user from the responsibility of documenting the problems themselves.

          - Similarly, when the user encounters a new need, the prototyper will generate a new user request on the behalf of the user and document it.
          ---
          ##<center>**How Operational Prototyping Works (contd.)**</center>
          ___

          - Once the user has finished reviewing the prototype, the prototyper will generate a quick and dirty prototype of a new system based on the top of the baseline, with the new feature requests included.

          - The new system is deployed to the users.
            - If the users like the changes, then feature-enhancement features are written by the prototyper and the new prototype is stowed away for later reference.
            - If the users do not like the change, then the new features are scrapped.

          - Over time new changes are proposed and new feature-enhancement requests are generated. These changes are then taken into account and the developers start working on a new baseline system using conventional development practices.
            - Code from the throwaway (quick-and-dirty) prototype is never used in the production code.
          ---


          

       </textarea>
		    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
		    </script>
		    <script>
		      var slideshow = remark.create();
		    </script>
    </body>
</html>
