<!DOCTYPE html>
<html>
  	<head>
     <title>Software Prototyping</title>
     <meta charset="utf-8">
     <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3,h4{
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
     </style>
  	</head>
    <body>
	     <textarea id="source">
          #<center>** Prototyping**</center>
          <img src="img/prototyping1.png" width="800" height="500" align="middle" />




          ---
          ##<center>**Table of Contents**</center>


          ---
          ##<center>**What is prototyping**</center>
          ___
          ### A prototype is an incomplete version of a software system being developed, that is used to demonstrate concepts, try out design options and, generally, to find out more about the problem and its possible solutions.

          + It is built so that the users can experience some of the proposed features and functionality of the software.
          <br>
          <br>
          + Typically, it simulates only a few aspects of the features of the final system, but may be completely different from the final implementation.
          ---

          ##<center>**Need for prototyping**</center>
          ___

          + ### A better quality system can be delivered
          <p style='text-align: justify;'>
          Many a times the developers may not fully understand the requirements and the expectations of the end users. Prototyping enables that the misunderstandings which occur can be identified and sorted out early on in the process.
          </p>

          + ### Problems can be identified early on
          <p style='text-align: justify;'>
          Using a prototype, makes a working system available early on in the process. The user can then identify possible improvements which can be made before the system is completed.
          </p>

          ---
          ##<center>**Need for prototyping**</center>
          ___

          + ### Better involvement of end users
          <p style='text-align: justify;'>
          The end user feels more involved in the development of the system and will 'buy' into it.
          </p>


          + ### Leads to fulfillment of user requirements
          <p style='text-align: justify;'>
          A system which has been through prototyping will generally have an improved design quality and will be far closer to what the user needs.

          </p>

          + ### Cost savings
          <p style='text-align: justify;'>
          Identifying and rectifying the problems with the system in the early stages of development is less expensive than towards the end of the development phase.
          </p>

          + ### Training
          <p style='text-align: justify;'>
          The prototype developed can be used to help train the staff while the real system is still being under development.

          </p>
          ---

          ##<center>**Hardware Prototyping  vs  Software Prototyping**</center>
          ___

          ###Software prototyping and hardware prototyping have different objectives.


          + While developing hardware systems, a prototype is generally used to validate the system design.  eg. A prototype for an electronic system may be developed using previously used  components before investment is made in expensive and special integrated circuits to build the final version of the system.
          <br>
          <br>

          + A software prototype is not normally intended for design validation but to help develop and check the reality of the requirements for the system. The prototype design is usually different from that of the final software system.
          ---

          ##<center>**The process of prototype development**</center>
          ___
          <img src="img/PrototypingObjectives.PNG" width="800" height="300" align="middle" />

          ---

          ##<center>**The process of prototype development**</center>
          ___
          A process model for prototype development is shown in the previous figure.

          + The objectives of prototyping should be made explicit and definite from the start of the process. These objectives can be to develop a system for prototyping the user interface, or to validate functional requirements of the system or a prototype to demonstrate the feasibility of the the proposed system to the management. <br>
          The same prototype cannot satisfy all the objectives. Leaving the objectives unstated, may lead to  misunderstanding of the function of the prototype to the management or end-users.

          + The next stage in the process is to decide what to include and more importantly, what to leave out of the prototype system. We need to exclude some functionality out of the
          prototype to reduce prototyping costs and speed up the delivery schedule. <br>
          We can also exclude the non-functional requirements such as response
          time, memory utilization, security, reliability.

          ---


          ##<center>**The process of prototype development**</center>
          ___

           + After building the prototype, the final stage of the process is that of prototype evaluation. <br>

           Provision must be made during this stage for user training, and the prototype objectives should be used to derive a plan for evaluation. Users need time to adapt with a new system and to settle into a normal pattern of usage. Once they start using the system normally, they then are able to discover problems in requirements and other missing features.

          ---


           ##<center>**Prototypes as design artifacts**</center>
          ___


          When successful prototypes are viewed as artifacts of design process,
          we can find several similar characteristics in them.

          + They support creativity and help the developer in capturing and generating ideas, and in gathering relevant information about the users and their background.


          + They enable communication between the various stake holders, helping designers, engineers,
          managers, software developers, customers and users to interact with each other.

          + They also permit early evaluation through usability studies and informal user
          feedback, throughout the design process.


          ---

          ##<center>**Prototypes as design artifacts**</center>
          ___


          Prototypes and prototyping techniques can be analyzed along four dimensions:
          + Representation describes the tangible forms of the prototype, e.g., paper
          sketches or computer simulations.
          <br><br>
          + Precision describes the level of detail at which the prototype is
          evaluated e.g. A rough prototype or a highly polished one.
          <br><br>
          + Interactivity describes the extent to which the user can interact with
          the prototype e.g., view-only prototype or a fully interactive one.
          <br><br>
          + Evolution describes the expected life-cycle of the prototype. e.g. throwaway
          or iterative.


          ---

           ##<center>**Representation**</center>
          ___

          A prototype can be series of paper sketches or it can be a computer simulation showing the details. Based on these different forms, we can classify prototypes as:
          <br>

          + Off-line prototypes
            + These generally include paper sketches, whiteboard illustrations, cardboard mockups and videos.
            + They can be created quickly, usually during the early stages of design, and are
            usually thrown away after they have served their purpose.

          + On-line prototypes
            + These are computer based prototypes which include computer animations, interactive video presentations, programs written with scripting languages, and applications developed with interface builders.
            + The cost of producing such prototypes is usually higher, and skill requirement to build such prototypes is also high.
            + They are effective in the later stages of the design process, when the basic design strategy has been decided.

          ---
          ##<center>** Off-line vs On-line prototypes **</center>
          ___
          + Off-line prototypes are very inexpensive and quick to build. This allows a rapid iteration cycle and helps in examining a variety of design alternatives.

          + Off-line prototypes are less likely to constrain the thinking of the designer. The  programming languages or development environments used in on-line prototyping impose constraints on the interface, thereby limiting creativity and restricting the number of ideas.

          + Off-line prototypes have the advantage of being created by a wide range of people.
           It is limited not just to programmers, but all types of designers, users, managers and others can all contribute equally.

          +  However, off-line prototypes are are insufficient to fully evaluate a particular design idea. e.g. An interface which is required to give rapid feedback to the users or to produce dynamic visualizations will usually require on-line prototypes .

          ---

          ##<center>**Precision**</center>
          ___

          Precision is the level of details with respect to the purpose of the prototype. <br><br>
          e.g. While designing a dialog box, it is necessary to specify the size and positions of the various elements of the box. But it's not required to decide the actual content text in detail.

          + The aspects of the prototype that are not precisely stated are the ones which are open for further discussion or for exploration. <br><br>
          + The precision level increases with the development of successive prototypes and as more details are set. <br><br>
          + The representation forms of the prototypes reflect their level of precision: hand drawn sketches aren't that precise unlike computer simulations which are usually very precise.


          ---
          ##<center>**Interactivity**</center>
          ___

          Illustrating how the user will interact with the system is an important aspect of designing an interactive prototype. Prototypes can support different types of interaction -

          + Fixed prototypes are the non-interactive ones where the user cannot interact with them.
          e.g.video clips or pre-computed animations. Fixed prototypes simply portray what the interaction might look like.
          <br><br>
          + Open prototypes support large number of interactions. Such prototypes work like the
          real system, with some limitations. They usually only cover a certain part of the system and have limited performance and error-handling capabilities  as compared to the final system.


          ---

          ##<center>**Evolution**</center>
          ___
          Prototypes can be classified into the following based on their different life spans:
          + Rapid prototypes are built for a specific purpose and are then discarded away. They must be be inexpensive and easy to produce.<br><br>

          + Iterative prototypes are meant to evolve, either for working out specific details or for exploring different alternatives. <br><br>

          + Evolutionary prototypes are the ones which are designed to become part of the final system. As they are meant to be a part of the final system , they require greater planning and practice than the above approaches.


          ---

          ##<center>**Prototyping Elements**</center>

          ---

          ##<center>**Prototyping strategies**</center>

          ---
          ##<center>**Prototyping Techniques**</center>
          ___


          The basic idea behind the prototyping approach is to be able to develop a prorotype
          of a system as quickly as possible. This allows feedback from all stakeholders to
          be given early in the software process.

          The main prototyping techniques are -

          - Executable specification languages

          - Very high-level languages

          - Application generators and fourth-generation languages

          - Composition of reusable components

          The above mentioned techniques can be used in combinations. Some part of the software
          system may use one technique while some other part could be done more efficiently using
          some other technique.

          ---
          ### 1. Executable Specification Techniques
          ___


          Using a formal specification to develop a prototype is useful as it combines unambiguous
          specification with a prototype. But when this is applied practically, there are many
          constraints -

          - Graphical user interfaces are extremely difficult to prototype using this technique. The

          - Prototype development may not be very rapid to start withusing this technique as it requires
          a detailed analysis of the system, functions, and features that were rejected earlier and features
          which need to be included.

          - Executable specifications mainly test only functional requirements.

          ---
          ### 2. Very high-level languages
          ___

          These  are generaally programming languages which have powerful data managament facilities and
          efficient memories. However, dynamic languages of this genre are not used as they requirea large
          run-time support system which in turn increases the storage that is required.

          Smalltalk is an object oriented programming language that is excellent for prototyping due to-

          - Rapid modifications of a Smalltalk system are possible without unforeseen effects on the rest of
          the system.

          - All the objects defined in the environment are available to the programmer which helps in reusability.

          - Partial automation in the construction of user interfaces for interactive systems is supported in some
          versions.
          ---
          ### 2. Very high-level languages - Continued
          ___

          REFINE is a class of wide-spectrum programming languages used for prototyping.
          A wide-spectrum language is a programming langauge which combines a number of paradigms. It may include
          objects, imperative constructs and logic programming which are also provided separatelt by languages such as
          Pascal, Lisp and Prolog.

          The mixed language support involves programming different parts of the system in different languages. A commication
          framework needs to be estabilished between the different parts in this case.

          The advantage of this approach is that for each part, the most appropriate language can be chosen which can speed up
          prototype development.

          The disadvantage is that it may be diffuclt to estabilish an interface which allows the communcation of multiple languages

          ---
          ##<center>**Throwaway/Rapid Prototyping  **</center>

          ---

          ##<center>**Throwaway/Rapid Prototyping  **</center>
          [!img]
          ---


          ##<center>**Off-line rapid prototyping techniques **</center>

          ---

          ##<center>**On-line rapid prototyping techniques **</center>

          ---

          ##<center>**Disadvantages of throw away prototyping **</center>

          ---

          ##<center>**Evolutionary Protoyping**</center>
          ___

          <center><center><br><br><br><br><br>
          ![Evolutionary Protoyping](img/evolutionary.jpg)
          ---
          ##<center>**Introduction**</center>
          ___
          The main goal of the evolutionary prototyping approach is to develop a
          mature, efficient, reliable, cost-effective software system or a solution
          through a series of prototyping iterations.

          The prototype undergoes continuous iterations and gets refined at each iteration.
          At each iteration, the implementation is handed over to the customer for their
          feedback. Ultimately, what started out as the prototype should become the solution.

          At each iteration, the system can be considered as first draft, second draft and
          so on till the final version is ready. Evolutionary prototyping is useful in developing
          systems where it is extremely difficult to establish a detailed system specification document.

          ---
          ##<center>**Approach of Evolutionary Prorotyping**</center>
          ___

          An important factor that determines the success of this approach is the use of techniques and tools
          which allow for rapid system iterations. The changes that are suggested by the customer need to be
          incorporated and demonstrated again to the customer as quickly as possible. This can include the use
          of high level programming languages for software development, special environments, integrated software
          tools etc that can accelerate the developmen process.

          One key differnce between Evolutionary prototyping and specification-based approaches is the verification
          and validation. Verification is done by comparing the program, software system or solution to its
          specifications. Without having a specification, verification cannot be done. Validation process is done
          to ensure that the system is working as it is intended rather than its conformance to a speicifcation.

          ---
          ##<center>**Disadvantages**</center>
          ___

          Trying to decide how adequate a system is difficult as it is not measurable. Human performance is
          not always guaranteed to be correct but we are satisifed if performance is adequate for the current task.

          When it comes to developing systems that are expected to last a very long time, this could be a bigger
          problem. The main problems associated with evolutionary prototyoing are -

          - Prototypes usually develop so quickly that is not cost-effective to produce a great deal of system
            documentation and schedules.

          - Continuous changes to a system could lead to its corruption.

          - Generally for such approaches, small teams of highly skilled and passionate individuals have been used
            effectively. But it is still not clear as to what comprises the perfect team.

          - It is difficult to set a budget and schedule.

          ---
          ##<center>**Advantages**</center>
          ___

          - Since prototypes are generally developed quickly to get customer feedback quickly, this approach
          speeds up the delivery of the system. The changes suggested by the customer are implemented quickly
           and effectively.

          - The user is constantly involved with the team during the development of the software solution.

          - Constant customer interaction ensures that the end prodcut meets user requirements as much as possible.

          - There is constant refinement of the software product.

          - Compared to Throwaway Prototyping, the prototypes developed using this approach are functional prototypes,
           even though the developers may not have implemented all the features mentioned by the customer.

          ---


       </textarea>
		    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
		    </script>
		    <script>
		      var slideshow = remark.create();
		    </script>
    </body>
</html>
